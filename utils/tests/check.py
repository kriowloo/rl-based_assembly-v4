# This auxiliary code is aimed to test image generation of RL assembler.
# It is necessary to have some pictures generated by the assembler before using it.
# These images will be checked to confirm if they were generated correctly.
# Thus, generate such images using one of the five approaches for image generation.
# Save these images in a folder named typeX, where X corresponds to the number
# of the corresponding approach used (from 1 to 5) - see software usage to
# check the number of each approach.
# All pictures have to be named following this pattern: READID1-READID2-...READIDN_Z.png,
# where READID1 is the position of the first read drawed in the image (i.e. the read
# at the first row of the image), READID2 is the second, and so on. Additionally,
# Z correspond to the number of the image for this order of reads. As only the approach
# number 1 generates two images, all other approaches will replace Z for 0. In the
# case of approach 1, the image representing the forward order will have Z equals to
# 0 and the other image (backward) will have 1.
# Put this script in the same folder where typeX was created (and not within typeX).
# Change line 142 of this code, adding the reads in the same order used in the assembler.
# Execute this script passing the number of X as argument (e.g.: python3 check.py 3).
# It will print all images found and before their name True if they are correct
# and False otherwise.
# Example of folder tree to perform one test (considering /home/user as base dir,
# 3 read ordering to check, and type equals 1 - i.e.: two images for each read ordering):
# | home
# --| user
# ----| check.py
# ----| type3
# ------| 5-3-9-4-2_0.png
# ------| 5-3-9-4-2_1.png
# ------| 10-12-5_0.png
# ------| 10-12-5_1.png
# ------| 28-1-13-24-11-8_0.png
# ------| 28-1-13-24-11-8_1.png

import sys
import os
from scipy import misc

def file2matrix(image_path):
    return misc.imread(image_path)

def getOverlapPosition(reads, from_read_id, to_read_id):
    if from_read_id != -1:
        cur_pos = None
        read1 = reads[from_read_id]
        read2 = reads[to_read_id]
        for i in range(len(read1)):
            p1 = read1[i:]
            p2 = read2[:len(p1)]
            if p1 == p2:
                return i
    return -1

def getPixelValue(nucleotide):
    return ['A', 'C', 'G', 'T'].index(nucleotide) * 30 + 135

def getDefaultPixelValues():
    pixel_values = {}
    pixel_values['A'] = [getPixelValue('A')]
    pixel_values['C'] = [getPixelValue('C')]
    pixel_values['G'] = [getPixelValue('G')]
    pixel_values['T'] = [getPixelValue('T')]
    pixel_values['#'] = [255]
    return pixel_values

def getPixelValuesLeftImage():
    pixel_values = {}
    nucleotides = [ 'A', 'C', 'G', 'T']
    for i in range(len(nucleotides)):
        pixel_values[nucleotides[i]] = [10 * (5 * (i+1) - 1 + j) for j in range(5)]
    pixel_values['#'] = [0, 10, 20, 30, 255]
    return pixel_values

def getPixelValuesRightImage():
    pixel_values = {}
    nucleotides = [ 'A', 'C', 'G', 'T']
    for i in range(len(nucleotides)):
        pixel_values[nucleotides[i]] = [10 * (5 * j + i) for j in range(5)]
    pixel_values['#'] = [40, 90, 140, 190, 255]
    return pixel_values

def check(image_path, reads, read_order, type):
    if type == 1:
        return _check(image_path, reads, read_order)[0] if image_path.endswith("0.png") else _check(image_path, reads, read_order[::-1])[0]
    if type == 2:
        c1, m1 = _check(image_path, reads, read_order)
        c2, m2 = _check(image_path, reads, read_order[::-1])
        return m1 >= m2 and c1 or m2 >= m1 and c2
    if type == 3:
        c1, m1 = _check(image_path, reads, read_order, getPixelValuesLeftImage())
        c2, m2 = _check(image_path, reads, read_order[::-1], getPixelValuesRightImage())
        return c1 or c2
    if type == 4:
        c1, m1 = _check(image_path, reads, read_order)
        c2, m2 = _check(image_path, reads, read_order[::-1])
        return c1 or c2
    if type == 5:
        return _check(image_path, reads, read_order)[0]


def _check(image_path, reads, read_order, pixel_values = None):
    if pixel_values is None:
        pixel_values = getDefaultPixelValues()
    generated_image = file2matrix(image_path)
    max_width = 0
    last_read_id = -1
    for row in range(len(generated_image)):
        width = len(generated_image[row])
        if row < len(read_order):
            cur_read_id = read_order[row]
            cur_read = reads[cur_read_id]
            ol = getOverlapPosition(reads, last_read_id, cur_read_id)
            start = 0 if ol == -1 else ol + start
        else:
            start = width
            cur_read_id = -1
            cur_read = ""

        for col in range(width):
            pixel_value = generated_image[row][col]
            pixels_correct = pixel_values['#'] if col < start or col >= start + len(cur_read) else pixel_values[cur_read[col - start]]
            if 255 not in pixels_correct and col > max_width:
                max_width = col
            if not pixel_value in pixels_correct:
                return False, max_width
        last_read_id = cur_read_id

    return True, max_width

def batch(path, reads, type):
    for r, d, f in os.walk(path):
        for file in f:
            order = [int(read_id) for read_id in file.split("_")[0].split("-")]
            result = check(os.path.join(r, file), reads, order, type)
            print(str(result) + ": " + file)

if __name__ == "__main__":
    if len(sys.argv) != 2 or not sys.argv[1].isdigit() or int(sys.argv[1]) < 1 or int(sys.argv[1]) > 5:
        print("Argument list not valild")
        sys.exit(1)

    type = int(sys.argv[1])
    prefix = "type"
    reads = ['ACTAGCAATACGCTT', 'ACTAGCAATACGCTT', 'AATACGCTTGCGTTC', 'ACTAGCAATACGCTT', 'ACGCTTGCGTTCGGT', 'TACGCTTGCGTTCGG', 'AATACGCTTGCGTTC', 'AATACGCTTGCGTTC', 'CTAGCAATACGCTTG', 'TACTAGCAATACGCT', 'CTAGCAATACGCTTG', 'CAATACGCTTGCGTT', 'TACGCTTGCGTTCGG', 'AATACGCTTGCGTTC', 'AATACGCTTGCGTTC', 'CAATACGCTTGCGTT', 'TACGCTTGCGTTCGG', 'CAATACGCTTGCGTT', 'AATACGCTTGCGTTC', 'ACTAGCAATACGCTT', 'ACTAGCAATACGCTT', 'ACTAGCAATACGCTT', 'AGCAATACGCTTGCG', 'CTAGCAATACGCTTG', 'ATACGCTTGCGTTCG', 'GCAATACGCTTGCGT', 'ATACGCTTGCGTTCG', 'ACTAGCAATACGCTT', 'ATACGCTTGCGTTCG', 'TAGCAATACGCTTGC']
    path = prefix + str(type)
    batch(path, reads, type)
